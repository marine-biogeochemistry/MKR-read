<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PICO W BLE Listener</title>
  <link rel="manifest" href="manifest.json">
   <style>

    body { font-family: sans-serif; margin: 20px; }
    #bluetoothData { 
      border: 1px solid #ccc; 
      padding: 10px; 
      background: #eef; 
      white-space: pre-wrap; 
      height: 100px; 
      overflow-y: scroll;
      font-size: 13px; 
      resize: vertical;}
    button { margin: 5px; padding: 8px 12px; font-size: 12px; }
    
    #relayLogOutput {
      border: 1px solid #ccc;
      padding: 10px;
      background: #f9f9f9;
      white-space: pre-wrap;
      height: 50px;      /* ğŸ‘‰ Adjust height as needed */
      overflow-y: scroll;
      font-size: 13px;    /* ğŸ‘‰ Change font size for readability */
      resize: vertical;   /* ğŸ‘‰ Makes the box resizable by dragging */
    }

    /* Tab styles */
    .tab-container { margin-top: 20px; }
    .tab-buttons { display: flex; border-bottom: 1px solid #ccc; }
    .tab-button { 
      background: #f1f1f1; 
      border: none; 
      padding: 10px 20px; 
      cursor: pointer; 
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
    }
    .tab-button.active { background: #fff; border-bottom: 2px solid #007bff; }
    .tab-button:hover { background: #e9e9e9; }
    .tab-content { 
      display: none; 
      padding: 20px; 
      border: 1px solid #ccc; 
      border-top: none; 
      background: #fff;
    }
    .tab-content.active { display: block; }

    /* Status box (separate from the main readout) */
    #statusBox {
      border: 1px solid #007bff;
      background: #f0f8ff;
      padding: 10px;
      margin-top: 12px;
      font-family: monospace;
      color: #003366;
      border-radius: 6px;
      min-height: 60px;
      max-width: 100%;
    }
  </style>
</head>
  <script>
    // Format date as YYYY-MM-DD in local timezone
    function formatLocalDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // Format time as HH:MM:SS in local timezone
    function formatLocalTime(date) {
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }

    // Initialize default date and time to current local time
    document.addEventListener('DOMContentLoaded', function() {
      const now = new Date();
      document.getElementById('startDate').value = formatLocalDate(now);
      document.getElementById('startTime').value = formatLocalTime(now);
      document.getElementById('rtcDate').value = formatLocalDate(now);
      document.getElementById('rtcTime').value = formatLocalTime(now);
    });

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js?v=2')
        .then(reg => console.log('Service worker registered:', reg.scope))
        .catch(err => console.error('Service worker registration failed:', err));
    }

    // Tab switching functionality
    function openTab(tabName) {
      // Hide all tab contents
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(content => content.classList.remove('active'));
      
      // Remove active class from all tab buttons
      const tabButtons = document.querySelectorAll('.tab-button');
      tabButtons.forEach(button => button.classList.remove('active'));
      
      // Show the selected tab content
      document.getElementById(tabName).classList.add('active');
      
      // Add active class to the clicked button
      event.target.classList.add('active');
      
      // Initialize schedule tab date/time if opened
      if (tabName === 'schedule') {
        const now = new Date();
        document.getElementById('startDate').value = formatLocalDate(now);
        document.getElementById('startTime').value = formatLocalTime(now);
      }
      // Initialize manual control tab date/time if opened
      if (tabName === 'manual-control') {
        const now = new Date();
        document.getElementById('rtcDate').value = formatLocalDate(now);
        document.getElementById('rtcTime').value = formatLocalTime(now);
      }
    }

    // Initialize first tab as active
    document.addEventListener('DOMContentLoaded', function() {
      // Set default active tab
      document.querySelector('.tab-button').click();
    });
  </script>
</body>



  <h1>Autosampler BLE Panel</h1>

  <div class="tab-container">
    <div class="tab-buttons">
      <button class="tab-button" onclick="openTab('main-control')">Main Control</button>
      <button class="tab-button" onclick="openTab('wifi-control')">WiFi Control</button>
      <button class="tab-button" onclick="openTab('schedule')">Schedule</button>
      <button class="tab-button" onclick="openTab('manual-control')">Manual Control</button>
      <button class="tab-button" onclick="openTab('help')">Help</button>
    </div>

    <div id="main-control" class="tab-content">
      <button onclick="connectAndListen()">ğŸ” Scan & Connect</button>
      <button onclick="clearBluetoothDisplay()">ğŸ§¹ Clear Display</button>
       <!-- <button onclick="sendShutdown()">ğŸ›‘ Hard Shutdown</button> -->
      <p id="selectedDevice"></p>
      <p id="connectionStatus" style="font-weight:bold;"></p>
      
      <h3>ğŸ“¡ System Data & Logs</h3>
      <button onclick="readLog()">ğŸ“¥ Read Log File</button>
      <button onclick="downloadLog()">ğŸ’¾ Download Log</button>
      <button onclick="clearLog()">ğŸ—‘ï¸ Clear Log</button>
    </div>

    <div id="wifi-control" class="tab-content">
      <h3>ğŸ“¶ WiFi Control</h3>
      <button onclick="wifiOn()">ğŸ“¶ Turn WiFi ON</button>
      <button onclick="wifiOff()">ğŸ“¶ Turn WiFi OFF</button>
      <button onclick="wifiStatus()">ğŸ“Š WiFi Status</button>
      <br><br>
      <button onclick="listFiles()">ğŸ“‚ List Files</button>
      <br><br>
      <label for="downloadFilename">ğŸ“¥ Download File:</label>
      <input type="text" id="downloadFilename" placeholder="Enter filename">
      <button onclick="downloadFile()">ğŸ’¾ Download</button>
      <br><br>
      <label for="uploadFile">ğŸ“¤ Upload File:</label>
      <input type="file" id="uploadFile">
      <button onclick="uploadFile()">â¬†ï¸ Upload</button>
      <br><br>
      <label for="deleteFilename">ğŸ—‘ï¸ Delete File:</label>
      <input type="text" id="deleteFilename" placeholder="Enter filename">
      <button onclick="deleteFile()">ğŸ—‘ï¸ Delete</button>
    </div>

    <div id="schedule" class="tab-content">
      <h3>ğŸ›  Generate Sample Schedule</h3>
      <label for="startDate">ğŸ“… Start Date:</label>
      <input type="date" id="startDate">
      <br>
      <label for="startTime">â° Start Time:</label>
      <input type="time" id="startTime" step="1">
      <br>
      <label for="sampleDelay">â± Delay between samples (minutes):</label>
      <input type="number" id="sampleDelay" min="1" value="20">
      <br>
      <label for="startIndex">ğŸ”¢ Start sample index (1-15):</label>
      <input type="number" id="startIndex" min="1" max="15" value="1">
      <br>
      <label for="numSamples">ğŸ”¢ Number of samples (max 15):</label>
      <input type="number" id="numSamples" min="1" max="15" value="15">
      <br>
      <button onclick="generateSampleSchedule()">ğŸ“… Generate Schedule</button>
      <!-- <button onclick="previewSchedule()">ğŸ‘ï¸ Preview Schedule</button> -->

      <h3>ğŸ“… Batch Schedule Generator</h3>
      <p>Enter multiple event times to send in bulk:</p>
      <textarea id="scheduleInput" rows="6" style="width:100%; font-family: monospace;" placeholder="e.g./202R at 2025-08-18 21:47:00"></textarea>
      <br>
      <button onclick="sendScheduleFile()">ğŸ“¤ Send Schedule File</button>
      <button onclick="readSchedule()">ğŸ“¥ Read Schedule File</button>
    </div>

    <div id="manual-control" class="tab-content">
      <h3>ğŸ”§ Manual Control</h3>
      <button onclick="sendReset()">ğŸ” Reboot Device</button>
      <button onclick="emergencyStop()">ğŸ›‘ Emergency Stop</button>
      
      <h4>ğŸ”Œ Relay Control</h4>
      <button onclick="relayOn()">ğŸ”Œ Turn Relay ON</button>
      <button onclick="relayOff()">ğŸ”Œ Turn Relay OFF</button>
      <button onclick="relayStatus()">ğŸ“Š Relay Status</button>
      
      <h4>ğŸ”§ Manual RS232 Command</h4>
      <label for="customCmd">Custom Command:</label>
      <input type="text" id="customCmd" placeholder="e.g., /2O03R or /1J1M2000S14A0M2000J0R" style="width: 300px;">
      <button onclick="sendCustomCmd()">ğŸ“¤ Send Command</button>
      
      <h4>ğŸ•’ Set RTC Time</h4>
      <label for="rtcDate">ğŸ“… Date:</label>
      <input type="date" id="rtcDate">
      <br>
      <label for="rtcTime">â° Time:</label>
      <input type="time" id="rtcTime" step="1">
      <br>
      <button onclick="setRTCTime()">ğŸ•’ Set RTC Time</button>
      <button onclick="syncRTCWithPC()">ğŸ”„ Sync with PC Time</button>
      
      <h4>âš™ï¸ Pump Sequence Configuration</h4>
      <button onclick="readSequenceConfig()">ğŸ“¥ Read Sequence File</button>
      <br><br>
      <div id="sequenceConfigPanel" style="display:none; border: 1px solid #ccc; padding: 10px; margin-top: 10px;">
        <label for="rinseCount">ğŸš¿ Number of Rinses:</label>
        <input type="number" id="rinseCount" min="0" max="10" value="2" style="width: 60px;">
        <br><br>
        <label for="pumpCycles">ğŸ’‰ Number of Pump Cycles:</label>
        <input type="number" id="pumpCycles" min="1" max="15" value="12" style="width: 60px;">
        <br><br>
        <button onclick="updateSequenceConfig()">ğŸ’¾ Update Sequence File</button>
        <button onclick="cancelSequenceEdit()">âŒ Cancel</button>
      </div>
    </div>

    <div id="help" class="tab-content">
      <h3>ğŸ“š Help & Documentation</h3>
      <p>Welcome to the PICO W BLE Panel! This interface allows you to control and monitor your Raspberry Pi Pico-based autosampler system via Bluetooth Low Energy (BLE).</p>
      
      <h4>ğŸ”— Main Control</h4>
      <p>Use this tab to connect to your Pico device, read system logs, and manage data.</p>
      <ul>
        <li><strong>Scan & Connect:</strong> Scan for and connect to nearby Pico devices.</li>
        <li><strong>Read Log File:</strong> Retrieve the current log from the device.</li>
        <li><strong>Download Log:</strong> Save the collected log data to your computer.</li>
        <li><strong>Clear Log:</strong> Erase the log on the device (irreversible).</li>
      </ul>
      
      <h4>ğŸ“¶ WiFi Control</h4>
      <p>Manage the device's WiFi connectivity and file operations.</p>
      <ul>
        <li><strong>Turn WiFi ON/OFF:</strong> Enable or disable WiFi on the device.</li>
        <li><strong>WiFi Status:</strong> Check the current WiFi connection status.</li>
        <li><strong>List Files:</strong> View files stored on the device.</li>
        <li><strong>Download/Upload/Delete Files:</strong> Transfer files to/from the device.</li>
      </ul>
      
      <h4>ğŸ›  Schedule</h4>
      <p>Create and send sampling schedules to the device.</p>
      <ul>
        <li><strong>Generate Sample Schedule:</strong> Create a schedule based on start time, delay, and sample count.</li>
        <li><strong>Batch Schedule Generator:</strong> Manually enter multiple schedule entries.</li>
        <li><strong>Send Schedule File:</strong> Upload the schedule to the device.</li>
        <li><strong>Read Schedule:</strong> Retrieve the current schedule from the device.</li>
      </ul>
      
      <h4>ğŸ”§ Manual Control</h4>
      <p>Direct control over device functions.</p>
      <ul>
        <li><strong>Reboot Device:</strong> Restart the Pico device.</li>
        <li><strong>Emergency Stop:</strong> Immediately halt all scheduled operations, stop the pump, and turn off the relay.</li>
        <li><strong>Relay Control:</strong> Turn the power relay on/off and check status.</li>
        <li><strong>Manual RS232 Command:</strong> Send custom commands to the autosampler hardware.</li>
        <li><strong>Set RTC Time:</strong> Synchronize the device's real-time clock.</li>
        <li><strong>Pump Sequence Configuration:</strong> Read and modify the default pump sequence settings stored in <code>default_sequence.txt</code>. You can adjust:
          <ul>
            <li><strong>Number of Rinses (0-10):</strong> How many times to rinse the valve before sampling.</li>
            <li><strong>Number of Pump Cycles (1-15):</strong> How many times to repeat the pump cycle. Each pump cycle dispenses approximately 6 mL of sample.</li>
          </ul>
          Changes are saved to the device and will apply to the next scheduled sampling operation.
        </li>
      </ul>

      <h4>Example of Manual RS232 Custom Command</h4>
      <p>Command: <code>/1J0S15A0M1000A7640M2000J1M2000S14A0M2000J0R</code></p>
      <p>Breakdown:</p>
      <ul>
        <li><strong>/1</strong>: Select valve 1</li>
        <li><strong>J0</strong>: Solenoid off</li>
        <li><strong>S15</strong>: Set speed to 15</li>
        <li><strong>A0</strong>: Dispense 0 mL</li>
        <li><strong>M1000</strong>: Wait 1000 ms</li>
        <li><strong>A7640</strong>: Dispense 6 mL (7640 units)</li>
        <li><strong>M2000</strong>: Wait 2000 ms</li>
        <li><strong>J1</strong>: Solenoid on</li>
        <li><strong>M2000</strong>: Wait 2000 ms</li>
        <li><strong>S14</strong>: Set speed to 14</li>
        <li><strong>A0</strong>: Dispense 0 mL</li>
        <li><strong>M2000</strong>: Wait 2000 ms</li>
        <li><strong>J0</strong>: Solenoid off</li>
        <li><strong>R</strong>: End command</li>
      </ul>
      <p>This sequence rinses the valve, dispenses sample, and rinses again.</p>
      
      <h4>Another Example: Pump Recovery</h4>
      <p>Command: <code>/1ZWR</code></p>
      <p>Use this command to reinitialize the pump after a power cycle.</p>
      
      <h4>Valve Control Commands</h4>
      <p>Commands for controlling valve positions (using valve address /2). Positions correspond to:</p>
      <ul>
        <li><strong>Reset:</strong> <code>/2wR</code> - Reset the valve</li>
        <li><strong>Position 1 (Waste):</strong> <code>/2O1R</code> - Move to waste position</li>
        <li><strong>Positions 2-16 (Samples 1-15):</strong> <code>/2O{N}R</code> - Move to sample position N-1 (replace {N} with 2-16)</li>
      </ul>
      <p>Note: The valve address is /2. The 'O' command sets the position, 'w' resets, and 'R' ends the command.</p>
      
      <h4>ğŸ“¡ System Data & Logs</h4>
      <p>The display area shows real-time data from the device, including status updates, log entries, and command responses.</p>
      
      <h4>âš ï¸ Important Notes</h4>
      <ul>
        <li>Ensure the relay is ON before sending commands that require power.</li>
        <li>Commands are sent via BLE; ensure a stable connection.</li>
        <li>Schedule times should be in the future.</li>
        <li>Use Chrome or Edge browser for best BLE compatibility.</li>
      </ul>
    </div>
  </div>

  <div id="statusBox" aria-live="polite">â° Current Time: --<br>ğŸ“… Next Schedule: --<br>Last updated: --</div>

  <div id="bluetoothData" style="margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap;"></div>

  <script>
    // Global variables for BLE
    let device = null;
    let txCharacteristic = null;
    let rxCharacteristic = null;
    let bleQueue = [];
    let isSending = false;
    let messageBuffer = [];
    let processBufferTimeout = null;
    let collectedLogLines = []; // Accumulate [LOG] lines for download
    // Track ACKs from the device for verification
    let ackState = { reloaded: null, saved: null, complete: false, lastEntryBuilt: null };
    
    // Store the last known status values
    const lastStatus = {
      startTime: 'N/A',
      currentTime: 'N/A',
      endTime: 'N/A',
      runtime: 'N/A',
      remaining: 'N/A',
      lastUpdated: 0
    };
    let isReconnecting = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 3000; // 3 seconds
    
    // Connection status elements
    const connectionStatus = document.getElementById('connectionStatus');
    const selectedDevice = document.getElementById('selectedDevice');

    // Function to update the status display with the latest values
    function updateStatusDisplay() {
      const statusBox = document.getElementById('statusBox');
      if (!statusBox) return;

      // Show placeholders if no status received yet
      if (lastStatus.lastUpdated === 0) {
        statusBox.innerHTML = 'â° Current Time: --<br>ğŸ“… Next Schedule: --<br>Last updated: --';
        return;
      }

      const isStale = (Date.now() - lastStatus.lastUpdated) > 5 * 60 * 1000;
      const current = (lastStatus.currentTime && lastStatus.currentTime !== 'N/A') ? lastStatus.currentTime : '--';
      const next = (lastStatus.startTime && lastStatus.startTime !== 'N/A') ? lastStatus.startTime : '--';
      const lastUpdatedStr = new Date(lastStatus.lastUpdated).toLocaleString();

      let html = `<div><strong>â° Current Time:</strong> ${current}<br><strong>ğŸ“… Next Schedule:</strong> ${next}<br><strong>Last updated:</strong> ${lastUpdatedStr}</div>`;

      if (!isStale) {
        if (lastStatus.endTime && lastStatus.endTime !== 'N/A') html += `<div>ğŸ›‘ Scheduled End Time: ${lastStatus.endTime}</div>`;
        if (lastStatus.runtime && lastStatus.runtime !== 'N/A') html += `<div>ğŸ•’ Scheduled Runtime: ${lastStatus.runtime}</div>`;
        if (lastStatus.remaining && lastStatus.remaining !== 'N/A') html += `<div>ğŸ“Š Remaining: ${lastStatus.remaining}</div>`;
      } else {
        html += `<div style="color:#a00; margin-top:6px;">Status stale</div>`;
      }

      statusBox.innerHTML = html;
    }
    
    // Periodically refresh the status display
    setInterval(updateStatusDisplay, 1000);
    
    // Update connection status in the UI
    function updateConnectionStatus(connected, message = '') {
      if (connected) {
        connectionStatus.textContent = 'âœ… Connected';
        connectionStatus.style.color = 'green';
      } else {
        connectionStatus.textContent = message || 'âŒ Disconnected';
        connectionStatus.style.color = 'red';
      }
    }

    // Handle disconnection and setup reconnection
    async function handleDisconnection() {
      console.log('Device disconnected, starting reconnection process...');
      updateConnectionStatus(false, 'ğŸ” Reconnecting...');
      
      if (isReconnecting) return;
      isReconnecting = true;
      reconnectAttempts = 0;
      
      await attemptReconnection();
    }
    
    // Attempt to reconnect to the device
    async function attemptReconnection() {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.log('Max reconnection attempts reached');
        isReconnecting = false;
        updateConnectionStatus(false, 'âŒ Connection lost - Click Scan & Connect');
        return;
      }
      
      reconnectAttempts++;
      console.log(`Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
      
      try {
        if (device) {
          await connectToDevice(device);
          console.log('Reconnection successful!');
          isReconnecting = false;
          updateConnectionStatus(true);
        }
      } catch (error) {
        console.error(`Reconnection attempt ${reconnectAttempts} failed:`, error);
        setTimeout(attemptReconnection, RECONNECT_DELAY);
      }
    }
    
    // Connect to a BLE device
    async function connectToDevice(device) {
      try {
        if (!device.gatt) throw new Error('Invalid device');
        
        // Handle disconnection
        device.addEventListener('gattserverdisconnected', handleDisconnection);
        
        const server = await device.gatt.connect();
        
        // Request larger MTU for longer messages
        try {
          await server.requestMTU(247);
          console.log('MTU set to 247');
        } catch (e) {
          console.log('MTU request failed, using default (23)');
        }
        
        const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
        
        // Get characteristics
        txCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e'); // TX (notify)
        rxCharacteristic = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e'); // RX (write)
        
        // Set up notifications
        await txCharacteristic.startNotifications();
        txCharacteristic.addEventListener('characteristicvaluechanged', handleBluetoothData);
        
        console.log('Successfully connected to device');
        updateConnectionStatus(true);
        selectedDevice.textContent = `Device: ${device.name || 'Unknown'}`;
        
        return true;
      } catch (error) {
        console.error('Connection error:', error);
        throw error;
      }
    }
    
    // Main connect function
    async function connectAndListen() {
      try {
        console.log('Requesting Bluetooth Device...');
        updateConnectionStatus(false, 'ğŸ” Scanning for BLE devices...');
        
        // Check if Bluetooth is available
        if (!navigator.bluetooth) {
          throw new Error('Web Bluetooth API not supported in this browser. Try Chrome or Edge.');
        }
        
        // Request Bluetooth permission first
        const availability = await navigator.bluetooth.getAvailability();
        if (!availability) {
          throw new Error('Bluetooth is not available. Make sure it\'s enabled.');
        }
        
        // First try to connect to already paired Pico devices
        console.log('Checking for already paired Pico devices...');
        try {
          const devices = await navigator.bluetooth.getDevices();
          const picoDevices = devices.filter(d => 
            d.name && d.name.startsWith('Pico')
          );
          
          if (picoDevices.length > 0) {
            // Use the first available Pico device
            device = picoDevices[0];
            console.log('Found paired Pico device:', device.name);
          } else {
            throw new Error('No paired Pico devices found');
          }
        } catch (pairedError) {
          console.log('No paired devices found, scanning for new Pico devices...');
          // Fall back to device discovery with specific filtering
          try {
            device = await navigator.bluetooth.requestDevice({
              filters: [
                { namePrefix: 'Pico' },
                { services: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e'] }
              ],
              optionalServices: ['generic_access']
            });
            console.log('Found new Pico device:', device.name || 'Unnamed Device');
          } catch (scanError) {
            console.error('BLE scan error:', scanError);
            if (scanError.name === 'NotFoundError') {
              throw new Error('No Pico devices found. Make sure your Pico is powered on and advertising.');
            } else if (scanError.name === 'SecurityError') {
              throw new Error('Bluetooth permission denied. Please allow access to Bluetooth devices.');
            } else {
              throw new Error(`Bluetooth error: ${scanError.message}`);
            }
          }
        }
        
        if (!device) {
          throw new Error('No device selected');
        }
        
        console.log('Selected device:', device.name || 'Unnamed device');
        updateConnectionStatus(false, 'ğŸ”— Connecting to device...');
        
        // Store the device in case we need to reconnect
        await connectToDevice(device);
        
      } catch (error) {
        console.error('Bluetooth error:', error);
        let errorMessage = 'Connection failed';
        
        if (error.name === 'NotFoundError') {
          errorMessage = 'No Bluetooth devices found. Make sure your Pico is powered on and in pairing mode.';
        } else if (error.name === 'SecurityError') {
          errorMessage = 'Permissions not granted. Please allow Bluetooth access.';
        } else if (error.message) {
          errorMessage = error.message;
        }
        
        updateConnectionStatus(false, `âŒ ${errorMessage}`);
      }
    }
    
    // Register Service Worker (optional PWA enhancement)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js')
          .then(reg => console.log("âœ… Service Worker registered"))
          .catch(err => console.error("âŒ SW registration failed:", err));
      });
    }

    async function processBleQueue() {
      if (isSending || bleQueue.length === 0) return;
      
      isSending = true;
      const { message, resolve, reject } = bleQueue.shift();
      
      if (!rxCharacteristic) {
        console.error('No BLE characteristic available');
        reject(new Error('No BLE characteristic available'));
        isSending = false;
        return;
      }
      
      try {
        // Convert the message to an ArrayBuffer
        const encoder = new TextEncoder();
        const data = encoder.encode(message);
        
        // Send the data (use WithResponse to match RX WRITE property)
        await rxCharacteristic.writeValueWithResponse(data);
        console.log('ğŸ“¤ Sent:', message);
        resolve();
      } catch (error) {
        console.error('Error sending BLE message:', error);
        reject(error);
      } finally {
        isSending = false;
        // Process next message in queue
        setTimeout(processBleQueue, 100);
      }
    }
    
    function sendBLEMessage(message) {
      return new Promise((resolve, reject) => {
        bleQueue.push({ message, resolve, reject });
        processBleQueue();
      });
    }

    function sendReset() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('RESET')
        .then(() => {
          console.log('ğŸ“¤ Sent: RESET');
          document.getElementById('connectionStatus').textContent = 'ğŸ” Reboot command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send reset command');
        });
    }

    function setRTCTime() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      
      // Get selected date and time from input fields
      const selectedDate = document.getElementById('rtcDate').value;
      const selectedTime = document.getElementById('rtcTime').value;
      
      if (!selectedDate || !selectedTime) {
        alert('Please select both date and time');
        return;
      }
      
      // Create Date object from selected values
      const selectedDateTime = new Date(`${selectedDate}T${selectedTime}`);
      
      // Extract components
      const year = selectedDateTime.getFullYear();
      const month = String(selectedDateTime.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDateTime.getDate()).padStart(2, '0');
      const hours = String(selectedDateTime.getHours()).padStart(2, '0');
      const minutes = String(selectedDateTime.getMinutes()).padStart(2, '0');
      const seconds = String(selectedDateTime.getSeconds()).padStart(2, '0');
      
      // Ultra-compact format: T:YYYYMMDDHHMMSS (16 chars total)
      const timeString = `T:${year}${month}${day}${hours}${minutes}${seconds}`;
      sendBLEMessage(timeString)
        .then(() => {
          console.log('ğŸ“¤ Sent:', timeString);
          document.getElementById('connectionStatus').textContent = 'ğŸ•’ RTC time set command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send set time command');
        });
    }

    function syncRTCWithPC() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      
      // Get current PC time
      const now = new Date();
      
      // Extract components
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      
      // Ultra-compact format: T:YYYYMMDDHHMMSS (16 chars total)
      const timeString = `T:${year}${month}${day}${hours}${minutes}${seconds}`;
      sendBLEMessage(timeString)
        .then(() => {
          console.log('ğŸ“¤ Sent (PC sync):', timeString);
          document.getElementById('connectionStatus').textContent = `ğŸ”„ RTC synced with PC time: ${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to sync RTC with PC time');
        });
    }

    function emergencyStop() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      
      if (!confirm('ğŸ›‘ EMERGENCY STOP: This will halt all scheduled operations and turn off the relay. Continue?')) {
        return;
      }
      
      // Send emergency stop flag to halt scheduler
      sendBLEMessage('EMERGENCY_STOP')
        .then(() => {
          console.log('ğŸ“¤ Sent emergency stop signal');
          document.getElementById('connectionStatus').textContent = 'ğŸ›‘ Emergency stop signal sent';
          
          // Send pump terminate command (T) - stops pump immediately
          return sendBLEMessage('SEND_CMD:/1TR');
        })
        .then(() => {
          console.log('ğŸ“¤ Sent pump terminate command: /1TR');
          
          // Also turn off relay for safety
          return sendBLEMessage('RELAY:OFF');
        })
        .then(() => {
          console.log('ğŸ“¤ Sent: RELAY:OFF');
          document.getElementById('connectionStatus').textContent = 'ğŸ›‘ Emergency stop complete - schedule halted, relay OFF';
        })
        .catch(err => {
          console.error('âŒ Emergency stop failed:', err);
          alert('âŒ Emergency stop command failed. Try turning off relay manually.');
        });
    }

    function relayOn() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('RELAY:ON')
        .then(() => {
          console.log('ğŸ“¤ Sent: RELAY:ON');
          document.getElementById('connectionStatus').textContent = 'ğŸ”Œ Relay ON command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send relay ON command');
        });
    }

    function relayOff() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('RELAY:OFF')
        .then(() => {
          console.log('ğŸ“¤ Sent: RELAY:OFF');
          document.getElementById('connectionStatus').textContent = 'ğŸ”Œ Relay OFF command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send relay OFF command');
        });
    }

    function relayStatus() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('RELAY:STATUS')
        .then(() => {
          console.log('ğŸ“¤ Sent: RELAY:STATUS');
          document.getElementById('connectionStatus').textContent = 'ğŸ“Š Relay status requested';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to request relay status');
        });
    }

    function sendShutdown() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      if (!confirm('Are you sure you want to hard shutdown the device? It will disconnect and may require a manual reset/power cycle to wake.')) {
        return;
      }
      sendBLEMessage('SHUTDOWN')
        .then(() => {
          console.log('ğŸ“¤ Sent: SHUTDOWN');
          document.getElementById('connectionStatus').textContent = 'ğŸ›‘ Shutdown command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send shutdown command');
        });
    }

    function wifiOn() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('wifi_on')
        .then(() => {
          console.log('ğŸ“¤ Sent: wifi_on');
          document.getElementById('connectionStatus').textContent = 'ğŸ“¶ WiFi ON command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send WiFi ON command');
        });
    }

    function wifiOff() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('wifi_off')
        .then(() => {
          console.log('ğŸ“¤ Sent: wifi_off');
          document.getElementById('connectionStatus').textContent = 'ğŸ“¶ WiFi OFF command sent';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to send WiFi OFF command');
        });
    }

    function wifiStatus() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('wifi_status')
        .then(() => {
          console.log('ğŸ“¤ Sent: wifi_status');
          document.getElementById('connectionStatus').textContent = 'ğŸ“Š WiFi status requested';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to request WiFi status');
        });
    }

    function listFiles() {
      fetch('http://192.168.4.1:5001/api/list')
        .then(response => response.json())
        .then(data => {
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          if (data.status === 'ok') {
            let fileList = `ğŸ“‚ Files (${data.total_count} total):\n`;
            data.files.forEach(file => {
              fileList += `  - ${file.name} (${file.size} bytes, ${file.location})\n`;
            });
            line.textContent = `[${timestamp}] ${fileList.trim()}`;
          } else {
            line.textContent = `[${timestamp}] âŒ List files error: ${data.message}`;
          }
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        })
        .catch(err => {
          console.error('List files error:', err);
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          line.textContent = `[${timestamp}] âŒ Failed to list files`;
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        });
    }

    function downloadFile() {
      const filename = document.getElementById('downloadFilename').value.trim();
      if (!filename) {
        alert('Please enter a filename to download');
        return;
      }
      fetch('http://192.168.4.1:5001/api/get?name=' + encodeURIComponent(filename))
        .then(response => {
          if (!response.ok) {
            throw new Error('Download failed');
          }
          return response.blob();
        })
        .then(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          // Show success in display
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          line.textContent = `[${timestamp}] âœ… Downloaded: ${filename}`;
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        })
        .catch(err => {
          console.error('Download error:', err);
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          line.textContent = `[${timestamp}] âŒ Download failed: ${filename}`;
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        });
    }

    function uploadFile() {
      const fileInput = document.getElementById('uploadFile');
      const file = fileInput.files[0];
      if (!file) {
        alert('Please select a file to upload');
        return;
      }

      fetch('http://192.168.4.1:5001/api/upload?name=' + encodeURIComponent(file.name), {
        method: 'POST',
        body: file
      })
        .then(response => response.json())
        .then(data => {
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          if (data.status === 'ok') {
            line.textContent = `[${timestamp}] âœ… Uploaded: ${file.name} (${data.bytes} bytes)`;
          } else {
            line.textContent = `[${timestamp}] âŒ Upload failed: ${data.message}`;
          }
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        })
        .catch(err => {
          console.error('Upload error:', err);
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          line.textContent = `[${timestamp}] âŒ Upload failed: ${file.name}`;
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        });
    }

    function deleteFile() {
      const filename = document.getElementById('deleteFilename').value.trim();
      if (!filename) {
        alert('Please enter a filename to delete');
        return;
      }
      if (!confirm(`Are you sure you want to delete "${filename}"?`)) {
        return;
      }
      fetch('http://192.168.4.1:5001/api/delete?name=' + encodeURIComponent(filename), {
        method: 'DELETE'
      })
        .then(response => response.json())
        .then(data => {
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          if (data.status === 'ok') {
            line.textContent = `[${timestamp}] âœ… Deleted: ${filename}`;
          } else {
            line.textContent = `[${timestamp}] âŒ Delete failed: ${data.message}`;
          }
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        })
        .catch(err => {
          console.error('Delete error:', err);
          const display = document.getElementById('bluetoothData');
          const timestamp = new Date().toLocaleTimeString();
          const line = document.createElement('div');
          line.textContent = `[${timestamp}] âŒ Delete failed: ${filename}`;
          display.insertBefore(line, display.firstChild);
          while (display.childNodes.length > 50) {
            display.removeChild(display.lastChild);
          }
        });
    }

    function fetchSchedule() {
        fetch("/schedule")  // Or whatever endpoint you define
            .then(response => response.text())
            .then(data => {
                document.getElementById("schedule-output").innerText = data;
            })
            .catch(err => {
                document.getElementById("schedule-output").innerText = "Error loading schedule.";
                console.error(err);
            });
    }

    function handleBluetoothData(event) {
      const bytes = new Uint8Array(event.target.value.buffer);
      const decoded = new TextDecoder().decode(bytes);
      const timestamp = new Date().toLocaleTimeString();

      console.log(`ğŸ“¡ [${timestamp}] Received:`, decoded);

      const display = document.getElementById('bluetoothData');
      const line = document.createElement('div');
      line.textContent = `[${timestamp}] ${decoded}`;
      display.insertBefore(line, display.firstChild);

      while (display.childNodes.length > 50) {
        display.removeChild(display.lastChild);
      }
    }

    function clearBluetoothDisplay() {
      document.getElementById("bluetoothData").innerHTML = "";
      collectedLogLines = [];
      console.log("ğŸ§¹ Display cleared");
    }

    function clearLog() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      if (!confirm('Are you sure you want to clear the log on the device? This cannot be undone.')) {
        return;
      }
      const message = 'CLEARLOG';
      rxCharacteristic.writeValue(new TextEncoder().encode(message))
        .then(() => {
          console.log('ğŸ“¤ Sent:', message);
          document.getElementById('connectionStatus').textContent = 'ğŸ§¹ Requested log clear on Pico W';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to request log clear');
        });
    }

    function downloadLog() {
      try {
        const content = collectedLogLines.join('\n');
        if (!content) {
          alert('No log lines collected yet. Click "Read Log File" first.');
          return;
        }
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `pico_log_${ts}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        // Keep lines for user to possibly download again; comment next line to retain
        // collectedLogLines = [];
      } catch (e) {
        console.error('Failed to download log:', e);
        alert('Failed to download log. See console for details.');
      }
    }

    function sendAddEvent() {
      const date = document.getElementById("eventDate").value;
      const time = document.getElementById("eventTime").value;
      const durationInput = document.getElementById("eventDuration").value;

      const defaultDuration = 60;
      const duration = durationInput && !isNaN(durationInput) ? durationInput : defaultDuration;

      if (!date || !time) {
        alert("â›”ï¸ Please enter both date and time.");
        return;
      }
      
      // Validate future date
      const selectedDate = new Date(date + 'T' + time);
      const now = new Date();
      if (selectedDate <= now) {
        alert("âš ï¸ Please select a future date and time.");
        return;
      }

      const message = `ADD:${date} ${time} ${duration}`;

      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "âœ… Event sent to Pico W";
            // Update the schedule input box with the new event
            const scheduleBox = document.getElementById("scheduleInput");
            const newLine = `${date} ${time} ${duration}`;
            scheduleBox.value = `${newLine}\n${scheduleBox.value}`.trim();
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to send BLE message");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }

    function sendDuration() {
      const durationValue = document.getElementById("eventDuration").value;

      if (!durationValue || isNaN(durationValue)) {
        alert("â›”ï¸ Please enter a valid duration number.");
        return;
      }

      const message = "DURATION:" + durationValue;

      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "âœ… Duration sent to Pico W";
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to send duration update.");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }

    function readLog() {
      const message = "GETLOG";
      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "ğŸ“„ Requested log file from Pico W";
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to request log data");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }

    function readSchedule() {
      const message = "READ_SCHEDULE";
      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "ğŸ“„ Requested schedule from Pico W";
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to request schedule data");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }

    function readSequence() {
      const message = "READ_SEQUENCE";
      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "ğŸ“„ Requested sequence from Pico W";
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to request sequence data");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }

    function sendCustomCmd() {
      const cmd = document.getElementById('customCmd').value.trim();
      if (!cmd) {
        alert('Please enter a command');
        return;
      }
      if (!rxCharacteristic) {
        alert('Not connected to device');
        return;
      }
      
      // Confirm relay is on
      if (!confirm('Make sure the relay is ON before sending the command. The pump/valve system requires power. Continue?')) {
        return;
      }
      
      // Split long commands into parts if needed (BLE MTU limit)
      const maxPartLength = 4; // Reduced to fit within default MTU of 23 bytes
      if (cmd.length <= maxPartLength) {
        sendBLEMessage('SEND_CMD:' + cmd);
      } else {
        // Send in parts
        const parts = [];
        for (let i = 0; i < cmd.length; i += maxPartLength) {
          parts.push(cmd.substr(i, maxPartLength));
        }
        
        // Send start marker
        sendBLEMessage('SEND_CMD_START:' + parts.length);
        
        // Send each part
        parts.forEach((part, index) => {
          sendBLEMessage('SEND_CMD_PART' + (index + 1) + ':' + part);
        });
        
        // Send execute marker
        sendBLEMessage('SEND_CMD_EXEC');
      }
    }

    function readSequenceConfig() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      sendBLEMessage('READ_SEQUENCE')
        .then(() => {
          console.log('ğŸ“¤ Sent: READ_SEQUENCE');
          document.getElementById('connectionStatus').textContent = 'ğŸ“„ Reading sequence config...';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to read sequence config');
        });
    }

    function updateSequenceConfig() {
      if (!rxCharacteristic) {
        alert('âš ï¸ BLE not connected yet.');
        return;
      }
      
      const rinses = document.getElementById('rinseCount').value;
      const pumps = document.getElementById('pumpCycles').value;
      
      if (!rinses || !pumps) {
        alert('Please enter valid values for rinses and pump cycles');
        return;
      }
      
      sendBLEMessage(`UPDATE_SEQUENCE:${rinses},${pumps}`)
        .then(() => {
          console.log(`ğŸ“¤ Sent: UPDATE_SEQUENCE:${rinses},${pumps}`);
          document.getElementById('connectionStatus').textContent = 'âœ… Sequence config updated';
          document.getElementById('sequenceConfigPanel').style.display = 'none';
        })
        .catch(err => {
          console.error('âŒ BLE write failed:', err);
          alert('Failed to update sequence config');
        });
    }

    function cancelSequenceEdit() {
      document.getElementById('sequenceConfigPanel').style.display = 'none';
    }

    function fetchNextTrigger() {
      const message = "NEXTTRIGGER";
      if (rxCharacteristic) {
        rxCharacteristic.writeValue(new TextEncoder().encode(message))
          .then(() => {
            console.log("ğŸ“¤ Sent:", message);
            document.getElementById("connectionStatus").textContent = "â© Requested next trigger info";
          })
          .catch(err => {
            console.error("âŒ BLE write failed:", err);
            alert("Failed to request next trigger");
          });
      } else {
        alert("âš ï¸ BLE not connected yet.");
      }
    }


    function processMessageBuffer() {
      const display = document.getElementById('bluetoothData');
      let combinedMessage = messageBuffer.join('\n');
      messageBuffer = [];
      let lastLine = ''; // Track the previous line for context
      let receivedFileLines = []; // Collect lines from READ_SCHEDULE
      let resetScheduleArea = false; // Reset textarea when header received
      
      // Log the raw message for debugging
      console.log('Processing buffered message:', combinedMessage);
      
      // Split the message into lines and process each one
      const lines = combinedMessage.split('\n').map(line => line.trim()).filter(line => line);
      
      // Check if this is a system status message
      const isStatusMessage = lines.some(line => 
        line.includes('Start Time') || 
        line.includes('Current Time') || 
        line.includes('Scheduled End Time') ||
        line.includes('Scheduled Runtime') ||
        line.includes('â° Current:') ||
        line.includes('â­ï¸ Next') ||
        line.includes('ğŸ“Š Remaining:')
      );
      
      if (isStatusMessage) {
        let statusLines = [];
        let lastTimestamp = '';
                
        // First, collect all timestamp lines
        const timestamps = lines.filter(line => /\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(line));
        
        // Then process each line
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          
          // Check for timestamp pattern (e.g., '2025-08-12 20:05:00')
          const timestampRegex = /\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/;
          
          // Check for scheduled runtime
          if (line.includes('Scheduled Runtime:')) {
            const runtimeMatch = line.match(/Scheduled Runtime: (.*)/);
            if (runtimeMatch) {
              lastStatus.runtime = runtimeMatch[1];
              lastStatus.lastUpdated = Date.now();
            }
          }
          // Check for compact status updates (â° Current: and â­ï¸ Next)
          else if (line.includes('â° Current:')) {
            const timeMatch = line.match(/â° Current:\s*(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
            if (timeMatch) {
              lastStatus.currentTime = timeMatch[1];
              lastStatus.lastUpdated = Date.now();
            }
          }
          else if (line.includes('â­ï¸ Next')) {
            const timeMatch = line.match(/â­ï¸ Next.*?(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
            if (timeMatch) {
              lastStatus.endTime = timeMatch[1];
              lastStatus.lastUpdated = Date.now();
            }
          }
          else if (line.includes('ğŸ“Š Remaining:')) {
            const remainingMatch = line.match(/ğŸ“Š Remaining:\s*(\d+\/\d+\s+samples?)/);
            if (remainingMatch) {
              lastStatus.remaining = remainingMatch[1];
              lastStatus.lastUpdated = Date.now();
            }
          }
          // Check for timestamps in format like '2025-08-13 09:10:00'
          else if (/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(line)) {
            // If this timestamp follows a Start Time or Current Time label, store it
            if (lastLine && lastLine.includes('Start Time')) {
              lastStatus.startTime = line.trim();
              lastStatus.lastUpdated = Date.now();
            } else if (lastLine && lastLine.includes('Current Time')) {
              lastStatus.currentTime = line.trim();
              lastStatus.lastUpdated = Date.now();
            } else if (lastLine && lastLine.includes('Scheduled End Time')) {
              lastStatus.endTime = line.trim();
              lastStatus.lastUpdated = Date.now();
            }
          }
          
          lastLine = line; // Store the current line for the next iteration
        }
        
        // Add battery status if available
        if (batteryStatus) {
          statusLines.push(`ğŸ”‹ ${batteryStatus}`);
        }
        
        // Remove any existing status messages
        const existingStatus = Array.from(display.querySelectorAll('.status-message'));
        existingStatus.forEach(el => el.remove());
        
        // Update the timestamp
        lastStatus.lastUpdated = Date.now();
        
        // Update the display with the latest status
        updateStatusDisplay();
      } else {
        // For non-status messages, add them directly to the display
        lines.forEach(text => {
          // Capture ACKs for verification
          if (text.startsWith('ACK:SCHEDULE_RELOADED')) {
            const m = text.match(/ACK:SCHEDULE_RELOADED\s+(\d+)/);
            if (m) ackState.reloaded = parseInt(m[1], 10);
          } else if (text.startsWith('ACK:SCHEDULE_SAVED')) {
            const m = text.match(/ACK:SCHEDULE_SAVED\s+(\d+)/);
            if (m) ackState.saved = parseInt(m[1], 10);
          } else if (text.startsWith('ACK:SCHEDULE_COMPLETE')) {
            ackState.complete = true;
          } else if (text.startsWith('ACK:ENTRY_BUILT')) {
            const m = text.match(/ACK:ENTRY_BUILT\s+(\d+)/);
            if (m) ackState.lastEntryBuilt = parseInt(m[1], 10);
          }
          
          // Parse sequence configuration response
          if (text.startsWith('SEQUENCE_CONFIG:')) {
            const match = text.match(/SEQUENCE_CONFIG:\s*RINSE\s+(\d+).*PUMP_CYCLES\s+(\d+)/);
            if (match) {
              const rinses = match[1];
              const pumps = match[2];
              document.getElementById('rinseCount').value = rinses;
              document.getElementById('pumpCycles').value = pumps;
              document.getElementById('sequenceConfigPanel').style.display = 'block';
              
              const line = document.createElement('div');
              line.textContent = `âš™ï¸ Sequence Config: ${rinses} rinses, ${pumps} pump cycles`;
              display.insertBefore(line, display.firstChild);
            }
            return;
          }

          if (text.startsWith('[FILE]')) {
            const rawBody = text.replace('[FILE]', '').trim();
            // Extract human-readable schedule line if wrapped in a dict-like string
            // e.g., {'time': '2025-08-18 19:29:00', 'raw': '/202R at 2025-08-18 19:29:00', 'command': '/202R'}
            let human = rawBody;
            const m = rawBody.match(/'raw':\s*'([^']+)'/);
            if (m) human = m[1];

            const line = document.createElement('div');
            line.textContent = `ğŸ“ Schedule: ${human}`;
            display.insertBefore(line, display.firstChild);
            // Also collect to populate the schedule textarea
            receivedFileLines.push(human);
          } else if (text.includes('ğŸ“… Current Schedule')) {
            // Header indicating a fresh schedule dump; clear textarea on apply
            resetScheduleArea = true;
          } else if (text.startsWith('NEXTTRIGGER')) {
            const line = document.createElement('div');
            line.textContent = `â³ Next Trigger: ${text.replace('NEXTTRIGGER', '').trim()}`;
            display.insertBefore(line, display.firstChild);
          } else if (text.startsWith('[LOG]')) {
            const body = text.replace('[LOG]', '').trim();
            collectedLogLines.push(body);
            const line = document.createElement('div');
            line.textContent = `ğŸ“„ Log: ${body}`;
            display.insertBefore(line, display.firstChild);
          } else if (text === 'LOG_CLEARED') {
            // Device confirmed log cleared; reset our local copy and notify
            collectedLogLines = [];
            const line = document.createElement('div');
            line.textContent = 'ğŸ§¹ Log cleared on device';
            display.insertBefore(line, display.firstChild);
          } else if (text === 'LOG_END') {
            // Auto-download when full log is sent
            if (collectedLogLines.length) {
              downloadLog();
            }
          } else if (!/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(text)) {
            // Only add if it's not a timestamp line by itself
            const line = document.createElement('div');
            line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            display.insertBefore(line, display.firstChild);
          }
        });
        // After processing, update the second window (scheduleInput textarea)
        if (receivedFileLines.length) {
          const scheduleBox = document.getElementById('scheduleInput');
          if (scheduleBox) {
            if (resetScheduleArea) {
              scheduleBox.value = receivedFileLines.join('\n');
            } else {
              scheduleBox.value = (scheduleBox.value ? scheduleBox.value + '\n' : '') + receivedFileLines.join('\n');
            }
          }
        }
      }
      
      // Limit the number of lines to prevent memory issues
      while (display.childNodes.length > 50) {
        display.removeChild(display.lastChild);
      }
    }
    
    function handleBluetoothData(event) {
      const bytes = new Uint8Array(event.target.value.buffer);
      const decoded = new TextDecoder().decode(bytes).trim();
      
      // Add message to buffer
      messageBuffer.push(decoded);
      
      // Clear any pending timeout
      if (processBufferTimeout) {
        clearTimeout(processBufferTimeout);
      }
      
      // Process buffer after a short delay to allow related messages to arrive
      processBufferTimeout = setTimeout(processMessageBuffer, 100);
    }

    function generateBatchSchedule() {
      const startDate = document.getElementById("eventDate").value;
      const startTime = document.getElementById("eventTime").value;
      const count = parseInt(document.getElementById("batchCount").value);
      const interval = parseFloat(document.getElementById("batchInterval").value); // days between each event (supports decimals)
      const duration = parseInt(document.getElementById("eventDuration").value) || 60; // in minutes

      if (!startDate || !startTime || isNaN(count) || isNaN(interval) || isNaN(duration)) {
        alert("â›”ï¸ Please fill out all fields correctly.");
        return;
      }

      const start = new Date(`${startDate}T${startTime}:00`);
      let output = "";

      for (let i = 0; i < count; i++) {
        const current = new Date(start.getTime() + i * interval * 24 * 60 * 60 * 1000);
        // Use local date formatting to avoid timezone issues
        const year = current.getFullYear();
        const month = String(current.getMonth() + 1).padStart(2, '0');
        const day = String(current.getDate()).padStart(2, '0');
        const hours = String(current.getHours()).padStart(2, '0');
        const minutes = String(current.getMinutes()).padStart(2, '0');
        
        const dateStr = `${year}-${month}-${day}`;
        const timeStr = `${hours}:${minutes}`;
        const line = `${dateStr} ${timeStr} ${duration}`;
        output += line + "\n";
        console.log(`âœ… Line ${i + 1}: ${line}`);
      }

      document.getElementById("scheduleInput").value = output.trim();
    }



    function generateSampleSchedule() {
      const startDate = document.getElementById('startDate').value;
      const startTime = document.getElementById('startTime').value;
      const sampleDelay = parseInt(document.getElementById('sampleDelay').value);
      const startIndex = parseInt(document.getElementById('startIndex').value);
      const numSamples = parseInt(document.getElementById('numSamples').value);
      
      if (!startDate || !startTime) {
        alert('Please set both start date and time');
        return;
      }
      
      // Accept indices 1â€“15; index 1 maps to /2O02R
      if (startIndex < 1 || startIndex > 15) {
        alert('Start index must be between 1 and 15');
        return;
      }
      
      let scheduleText = '';
      const startDateTime = new Date(`${startDate}T${startTime}`);
      
      // Generate entries starting exactly at the selected start time
      // Limit to at most 15 samples total and stop at /2O16R
      const maxByValve = 16 - startIndex; // with mapping 1=>/2O02R, last valve is 16
      const effectiveCount = Math.max(0, Math.min(numSamples, 15, maxByValve));
      for (let i = 0; i < effectiveCount; i++) {
        // Shift mapping by +1 so 1 => /2O02R
        const valveNum = startIndex + 1 + i;
        if (valveNum > 16) break; // Safety check: stop at 16
        
        const sampleTime = new Date(startDateTime.getTime() + (i * sampleDelay * 60000));
        // Format as YYYY-MM-DD HH:MM:SS in local time
        const formattedDate = formatLocalDate(sampleTime);
        const formattedTime = `${sampleTime.getHours().toString().padStart(2, '0')}:${sampleTime.getMinutes().toString().padStart(2, '0')}:00`;
        // Use 'O' format required by controller: e.g., /2O02R, /2O10R
        scheduleText += `/2O${valveNum.toString().padStart(2, '0')}R at ${formattedDate} ${formattedTime}\n`;
      }
      
      document.getElementById('scheduleInput').value = scheduleText.trim();
      logToDisplay('Schedule generated. Click "Send Schedule File" to upload to device.');
    }

    function previewSchedule() {
      generateSampleSchedule();
    }

    function logToDisplay(message) {
      const display = document.getElementById('bluetoothData');
      if (display) {
        const line = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString();
        line.textContent = `[${timestamp}] ${message}`;
        display.insertBefore(line, display.firstChild);
      }
      console.log(message);
    }
    
    async function sendScheduleFile() {
      const scheduleText = document.getElementById('scheduleInput').value;
      if (!scheduleText.trim()) {
        alert('Please generate a schedule first');
        return;
      }
      
      // Check if BLE is connected
      if (!device || !device.gatt.connected) {
        alert('Please connect to the device first');
        return;
      }
      
      // Disable the button to prevent multiple clicks
      const sendButton = document.querySelector('button[onclick="sendScheduleFile()"]');
      const originalText = sendButton.textContent;
      sendButton.disabled = true;
      sendButton.textContent = 'Sending...';

      // Process the schedule text to extract commands, dates, and times
      const entries = scheduleText.split('\n')
        .map(line => line.trim())
        .filter(line => line && line.includes(' at '))
        .map(line => {
          // Match format: /<alnum...>R at YYYY-MM-DD HH:MM:SS
          // Allows commands like /2O02R, /2O10R, /210R, etc.
          const match = line.match(/^(\/\S+R)\s+at\s+(\d{4}-\d{2}-\d{2})\s+(\d{1,2}:\d{2}:\d{2})/);
          if (match) {
            const [_, cmd, date, time] = match;
            return { cmd, date, time };
          }
          return null;
        })
        .filter(entry => entry !== null);

      if (entries.length === 0) {
        alert('No valid schedule entries found');
        return;
      }

      logToDisplay('ğŸ“ Sending schedule file...');
      
      try {
        logToDisplay('ğŸ“¤ Starting schedule transfer...');
        // Reset ACK tracking
        ackState = { reloaded: null, saved: null, complete: false, lastEntryBuilt: null };
        
        // Send the start command and wait for ACK
        logToDisplay('ğŸ”„ Sending schedule start command...');
        await sendBLEMessage('CMD:SCHEDULE_FILE');
        await new Promise(resolve => setTimeout(resolve, 500)); // Wait for ACK
        
        // Send all entries with proper sequencing
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const entryNum = i + 1;
          const totalEntries = entries.length;
          
          logToDisplay(`ğŸ“¤ Sending entry ${entryNum}/${totalEntries}: ${entry.cmd} at ${entry.date} ${entry.time}`);
          
          // Send command and wait for ACK
          await sendBLEMessage(`DATA:${entry.cmd}`);
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Send date and wait for ACK
          await sendBLEMessage(`DATA:${entry.date}`);
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Send time and wait for ACK
          await sendBLEMessage(`DATA:${entry.time}`);
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Update progress
          const progress = Math.round((entryNum / totalEntries) * 100);
          logToDisplay(`ğŸ“Š Progress: ${progress}% (${entryNum}/${totalEntries} entries)`);
        }
        
        // Send end command and wait for final ACK
        logToDisplay('ğŸ Sending schedule end command...');
        await sendBLEMessage('CMD:END_SCHEDULE');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        logToDisplay(`âœ… Successfully sent ${entries.length} schedule entries`);

        // Build expected plain-text lines for verification
        const expectedLines = entries.map(e => `${e.cmd} at ${e.date} ${e.time}`);

        // Verify by reading back from device and comparing to expected
        const verified = await verifyScheduleUpload(expectedLines);
        // Check ACK counts alongside readback verification
        const expectedCount = expectedLines.length;
        const ackOk = ackState.complete === true && ackState.reloaded === expectedCount && ackState.saved === expectedCount && ackState.lastEntryBuilt === expectedCount;
        if (verified.ok && ackOk) {
          logToDisplay('âœ… Upload finished and verified');
          document.getElementById('connectionStatus').textContent = 'âœ… Upload finished and verified';
        } else {
          let reason = verified.ok ? '' : `Readback: ${verified.message}`;
          if (!ackOk) {
            const parts = [];
            parts.push(`ACK complete=${ackState.complete ? 'yes' : 'no'}`);
            parts.push(`reloaded=${ackState.reloaded ?? 'n/a'}`);
            parts.push(`saved=${ackState.saved ?? 'n/a'}`);
            parts.push(`lastEntryBuilt=${ackState.lastEntryBuilt ?? 'n/a'}`);
            reason = (reason ? reason + '; ' : '') + parts.join(', ');
          }
          logToDisplay(`âš ï¸ Verification mismatch: ${reason}`);
          document.getElementById('connectionStatus').textContent = 'âš ï¸ Upload finished, verification mismatch';
        }
        
      } catch (error) {
        console.error('Error during schedule transfer:', error);
        logToDisplay('âŒ Error during schedule transfer');
      } finally {
        // Re-enable the button
        sendButton.disabled = false;
        sendButton.textContent = originalText;
      }
    }

    // Read back the schedule and compare with expected lines
    async function verifyScheduleUpload(expectedLines) {
      // Send READ_SCHEDULE which triggers the textarea to be updated via processMessageBuffer()
      try {
        await sendBLEMessage('READ_SCHEDULE');
      } catch (e) {
        return { ok: false, message: 'Failed to request schedule back' };
      }
      
      // Wait briefly for messages to arrive and be processed
      await new Promise(r => setTimeout(r, 1200));
      
      const textarea = document.getElementById('scheduleInput');
      if (!textarea) return { ok: false, message: 'Schedule textarea not found' };
      
      const gotLines = textarea.value
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0);
      
      // Simple equality check: same length and all lines equal, order preserved
      if (gotLines.length !== expectedLines.length) {
        return { ok: false, message: `Count differs (sent ${expectedLines.length}, got ${gotLines.length})` };
      }
      for (let i = 0; i < expectedLines.length; i++) {
        if (expectedLines[i] !== gotLines[i]) {
          return { ok: false, message: `Line ${i + 1} differs. Sent: "${expectedLines[i]}" Got: "${gotLines[i]}"` };
        }
      }
      return { ok: true };
    }

  </script>

</body>
</html>